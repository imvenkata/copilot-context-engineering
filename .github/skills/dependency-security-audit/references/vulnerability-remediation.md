# Vulnerability Remediation Guide

## Common Remediation Strategies

### 1. Direct Update
**When to use**: Patch or minor version available with the fix.

```bash
# Update to specific version
./scripts/update_dependencies.sh requests ">=2.31.0,<3.0.0"
```

### 2. Transitive Dependency Update
**When to use**: Vulnerability is in a sub-dependency.

```bash
# Find which package depends on the vulnerable package
pip show <vulnerable-package>

# Update the parent package
./scripts/update_dependencies.sh <parent-package>
```

### 3. Alternative Package
**When to use**: No fix available or package is unmaintained.

- Research alternative packages with similar functionality
- Ensure alternative is actively maintained
- Check compatibility with existing code
- Plan migration path

### 4. Temporary Mitigation
**When to use**: Critical issue with no immediate fix available.

- Apply input validation at boundaries
- Add runtime checks
- Document the risk in security.md
- Set reminder to check for updates weekly

### 5. Risk Acceptance
**When to use**: Low severity + low exploitability + no viable fix.

- Document in `SECURITY.md` or `docs/security-exceptions.md`
- Include CVE ID, severity, rationale, review date
- Set calendar reminder for re-evaluation (90 days)

## Severity Response Times

| Severity | Response Time | Action Required |
|----------|--------------|-----------------|
| Critical | Immediate | Patch within 24h or mitigate |
| High | 1-3 days | Patch within 1 week |
| Medium | 1-2 weeks | Patch in next release |
| Low | 1 month | Document and schedule |

## Testing After Updates

```bash
# Run security checks again
./scripts/run_pip_audit.sh
./scripts/run_safety_check.sh

# Run full test suite
pytest tests/

# Check for breaking changes
git diff requirements.txt poetry.lock
```

## Common CVE Patterns

### Path Traversal
- Validate all file paths
- Use `os.path.abspath()` and check prefix
- Never trust user input for file operations

### SQL Injection
- Use parameterized queries
- Never concatenate user input into SQL
- Use ORM where possible

### Command Injection
- Avoid shell=True in subprocess calls
- Use list form of subprocess arguments
- Validate and sanitize all inputs

### XSS (if web framework)
- Use framework's auto-escaping
- Never use `safe` or `|safe` with user input
- Validate content types

### Deserialization Vulnerabilities
- Never unpickle untrusted data
- Use JSON instead of pickle where possible
- Validate schemas before deserialization

## Documentation Template

```markdown
## Security Exception: <CVE-ID>

**Package**: <package-name>==<version>
**Severity**: <severity-level>
**CVE**: <CVE-ID>
**Reported**: <date>
**Review Date**: <date + 90 days>

**Description**:
<Brief description of vulnerability>

**Rationale for Acceptance**:
- [ ] No fix available from maintainer
- [ ] Low exploitability in our context because <reason>
- [ ] Mitigation in place: <describe mitigation>
- [ ] Alternative packages evaluated: <list alternatives and why not chosen>

**Mitigation**:
<Specific steps taken to reduce risk>

**Re-evaluation Plan**:
Check for updates on <date>. If still unresolved, escalate to security team.
```

## Resources

- [NVD - National Vulnerability Database](https://nvd.nist.gov/)
- [PyPI Advisory Database](https://github.com/pypa/advisory-database)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Python Security Best Practices](https://python.readthedocs.io/en/stable/library/security_warnings.html)
